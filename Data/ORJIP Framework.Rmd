---
title: "ORJIP project: Modelling framework for the joint analysis of survey and telemetry data in seabirds"
author: "Jason Matthiopoulos & Paul Blackwell"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    number_sections: true
biblio-style: apsr
fontsize: 12pt
geometry: margin=1in
header-includes:
- \usepackage{setspace}
- \usepackage{amsmath}
keywords: 
bibliography: ORJIP.bib
abstract: BLA. 
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(sm)
library(KernSmooth)
library(MASS)
library(sp) 
library(raster)
library(rgdal)
library(rgeos)
library(mapview)
library(ggplot2)
library(maps)
library(maptools)
library(mapdata)
library(mapproj)
library(tidyr)
library(corrplot)
library(inlabru)

```

```{r FUNCTIONS , message=FALSE, warning=FALSE, cache=TRUE, include=FALSE, echo=FALSE, error=FALSE,results='hide'}
####################################    FUNCTIONS   ###############################################################
# FUNCTION: Generates a random environmental layer in a square dxd arena using a total of x focal points
environ<-function(d,foci,bw, mini, maxi)
{
  rng<-(d+1):(2*d)
  # Places seeds in arena
  cox<-cbind(runif(3*foci, min=1, max=3*d), runif(3*foci, min=1, max=3*d))
  # Smooths seeds to create spatial autocorrelation
  smooth<-bkde2D(cox, bandwidth = c(bw,bw), gridsize=c(3*d,3*d),range.x=list(c(1,3*d),c(1,3*d)))
  layer<-smooth$fhat
  minl<-min(layer)
  maxl<-max(layer)
  layer<-((layer-minl)/(maxl-minl))*(maxi-mini)+mini
  return(layer[rng,rng])
}


```

# Simulation scenario
A realistic scenario for developing the framework would include the following features

- A sufficiently large spatial extent, compared to the grid resolution used. 
- A sufficiently complex coastline, to challenge the model with regard to land-shadowing effects.
- Multiple colonies of different sizes arranged along the coastline.
- Environmental covariates that may be continuous, or categorical. 
- Individual-level movement rules, to enable the model to collect tracking data
- A tendency to return to the colony periodically
- A distinction in the strength of this homing tendency between provisioning adults and juveniles
- Flexible and realistic user-defined options for the distribution of tagging effort (by colony and by individual)
- Flexible and realistic user defined options for transect survey design





## Environmental covariates
One continuous, one factor. 



```{r DataImport, message=FALSE, warning=FALSE,  cache=TRUE,echo=FALSE,error=FALSE}

#################################  DATA IMPORT ###########################################
#Rasters
bath<-raster::raster("Rasters/B3_EAEAC.tif") # Bathymetry data
names(bath)<-"Depth"
distCoast<-raster::raster("Rasters/Dist_Coast_EAEAC.tif") # Distance to coast data
names(distCoast)<-"dCoast"
habitats<-raster::raster("Rasters/rHabitats_EAEAC.tif") # Habitats
names(habitats)<-"habitats"

#Analysis area
studyA<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AnalysisArea2"),
  layer= "MG_AnalysisArea_Coast_to_5km_EAEAC",
  verbose=FALSE
  )
studyA<-rgeos::gSimplify(studyA,tol=1000)

#Area of development
studyA1<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AreaofSearch"),
  layer= "CS_AoS_Area1_20220909_EAEAC",
  verbose=FALSE
  )

#Coastline
coast<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/Coastline"),
  layer= "BDS_EEA_Coastline_Poly_EAEAC",
  verbose=FALSE
)


######################### COVARIATE PRE-PROCESSING ###############################
#crsDef<-bath@crs # Take projection reference from bathymetry data
crsDef<-crs(bath)
#crsDef<-CRS("+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs +type=crs")
xmin<- bbox(bath)[1,1]
xmax<- bbox(bath)[1,2]
ymin<- bbox(bath)[2,1]
ymax<- bbox(bath)[2,2]

aggr<-15 #Aggregation factor for covariates

# 1. Exact Coastline
coast<-sp::spTransform(coast, crsDef)
coast<-raster::crop(coast, extent(xmin,xmax,ymin,ymax))


# 2. Bathymetry
bath<-raster::projectRaster(bath, crs=crsDef)
bath<-raster::crop(bath, extent(xmin,xmax,ymin,ymax))
num<-na.omit(bath@data@values)
bath@data@values<-(bath@data@values-mean(num))/sqrt(var(num))
bathag<-raster::aggregate(bath, fact=aggr)
bathspdf<-as(bathag, "SpatialPixelsDataFrame")


f.bath <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  # Extract elevation values at spp coords, from our bathspdf SpatialGridDataFrame
  v <- over(spp, bathspdf)
  if (any(is.na(v$Depth))) {
    v$Depth <- inlabru:::bru_fill_missing(bathspdf, spp, v$Depth)
  }
  return(v$Depth)
}


bath.Plot<-ggplot()+
  gg(bathspdf)+ 
  gg(coast)+
  ggtitle("Bathymetry")+
  theme(axis.text.y =element_blank(), axis.text.x = element_blank())+
  gg(studyA1)


# 3. Habitats
habitats<-raster::projectRaster(habitats, crs=crsDef)
habitats<-raster::crop(habitats, extent(xmin,xmax,ymin,ymax))
habitatsag<-raster::aggregate(habitats, fact=aggr)
habitats<-as(habitatsag, "SpatialPixelsDataFrame")
habitats$habitats<-factor(as.character(round(habitats$habitats)))
habitats$habitats[habitats$habitats==2]<-0
habitats$habitats<-factor(as.character(habitats$habitats))
levels(habitats$habitats)<-c("Undetermined","Rock","Coarse sed","Mixed sed","Sand","Mud")

f.habitat <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  v <- over(spp, habitats)
  if (any(is.na(v$hab))) {
    v$hab <- inlabru:::bru_fill_missing(habitats, spp, v$hab)
  }
  return(v$hab)
}


habitat.Plot<-ggplot()+gg(habitats)+ gg(coast)+ggtitle("Habitats")+theme(axis.text.y = element_blank(), axis.text.x = element_blank())+  gg(studyA1)

# 4. Study Area
studyA1<-sp::spTransform(studyA1, crsDef)
studyA1<-raster::crop(studyA1, extent(xmin,xmax,ymin,ymax))
```
```{r EnvCovVisualisation, message=FALSE, warning=FALSE,  cache=TRUE,echo=FALSE,error=FALSE, fig.height=3, fig.width=8,  fig.align='center',fig.cap="\\label{Landscape} The coastline definition and the associated marine covariate"}
############### COVARIATE PLOTTING ############################

multiplot(bath.Plot,habitat.Plot, layout=matrix(c(1,2), 1,2))
```




## Derived covariates
Distance-to-colony calculation

```{r CovMatrices, message=FALSE, warning=FALSE,  cache=TRUE,echo=FALSE,error=FALSE}

#m.bath<-as.matrix(bath)
#image(m.bath)
roCol<-c(140,730)
coCol<-c(690,740)
pop<-c(2000,1000)

dis<-list()

for( i in 1:length(roCol))
{
  land<-bath*0+1
  land@data@values[is.na(land@data@values)]<-0
  land[roCol[i],coCol[i]]<-2
  d1<-gridDistance(land,origin=2, omit=0) 
  dis<-append(dis,d1)
  dinv<-pop[i]/(1+d1)^0.1
  if(i==1)
  {dCol<-dinv
  } else {
    dCol<-dCol+dinv
  }
}
num<-na.omit(dCol@data@values)
dCol@data@values<-(dCol@data@values-mean(num))/sqrt(var(num))
dColag<-raster::aggregate(dCol, fact=aggr)
dColspdf<-as(dColag, "SpatialPixelsDataFrame")

ggplot()+
  gg(dColspdf)+ 
  gg(coast)+
  ggtitle("Proximity to colonies")+
  theme(axis.text.y =element_blank(), axis.text.x = element_blank())+
  gg(studyA1)


```

## Individual-based simulation

## Survey transects
Import real transects and decide on different thinning regimes (i.e. truncate at ends, or introduce breaks between lines, how much to truncate, how long the breaks?)
Perform data collection

## Tagging effort
How many individuals, for how much time, what is the split in effort between the two colonies?
Perform data collection

# Inference

## Inference on telemetry data (SSF)

## Inference on survey data (HSF)

## Joint inference





# Appendix 