---
title: "ORJIP project: Modelling framework for the joint analysis of survey and telemetry data in seabirds"
author: "Jason Matthiopoulos, Paul Blackwell"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    number_sections: true
biblio-style: apsr
fontsize: 12pt
geometry: margin=1in
header-includes:
- \usepackage{setspace}
- \usepackage{amsmath}
keywords: 
bibliography: ORJIP.bib
abstract: BLA. 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sp) 
library(raster)
library(rgdal)
library(rgeos)
library(mapview)
library(ggplot2)
library(maps)
library(maptools)
library(mapdata)
library(mapproj)
library(tidyr)
library(corrplot)



bru_options_set(inla.mode = "experimental")
```

```{r DataImport, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE, echo=FALSE, error=FALSE,results='hide'}


################ DATA IMPORT #################################################
#Rasters
bath<-raster::raster("Rasters/B3_EAEAC.tif") # Bathymetry data
names(bath)<-"Depth"
distCoast<-raster::raster("Rasters/Dist_Coast_EAEAC.tif") # Distance to coast data
names(distCoast)<-"dCoast"
distCol<-raster::raster("Rasters/COL_Ki.tif") # Distance to colony KI
names(distCol)<-"dCol"
habitats<-raster::raster("Rasters/rHabitats_EAEAC.tif") # Habitats
names(habitats)<-"habitats"

#Analysis area
studyA<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AnalysisArea2"),
  layer= "MG_AnalysisArea_Coast_to_5km_EAEAC",
  verbose=FALSE
  )
studyA<-rgeos::gSimplify(studyA,tol=1000)

#Areas of interest
studyA1<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AreaofSearch"),
  layer= "CS_AoS_Area1_20220909_EAEAC",
  verbose=FALSE
  )
studyA2<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AreaofSearch"),
  layer= "CS_AoS_Area2_20220909_EAEAC",
  verbose=FALSE
)
studyA3<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/AreaofSearch"),
  layer= "CS_AoS_Area3_20220909_EAEAC",
  verbose=FALSE
)

#Coastline
coast<-rgdal::readOGR(
  dsn= paste0(getwd(),"/Shapefiles/Coastline"),
  layer= "BDS_EEA_Coastline_Poly_EAEAC",
  verbose=FALSE
)

################ GLOBAL OPTIONS ###############################################


#crsDef<-bath@crs # Take projection reference from bathymetry data
crsDef<-fm_sp_get_crs(bath)
#crsDef<-CRS("+proj=utm +zone=31 +datum=WGS84 +units=m +no_defs +type=crs")
xmin<- bbox(bath)[1,1]
xmax<- bbox(bath)[1,2]
ymin<- bbox(bath)[2,1]
ymax<- bbox(bath)[2,2]


################ PROCESS COVARIATE DATA ########################################

aggr<-5 #Aggregation factor for covariates

# 1. Rough Coastline from world maps
ukcoastpoly <- map("world", "uk", fill=TRUE, col="transparent",plot=FALSE, resolution=0)
xy<-cbind(ukcoastpoly$x, ukcoastpoly$y)
xyproj<-project(xy, as.character(crsDef))
ukcoastpoly$x<-xyproj[,1]
ukcoastpoly$y<-xyproj[,2]
IDs <- sapply(strsplit(ukcoastpoly$names, ":"), function(x) x[1])
ukcoastpolysp<-map2SpatialPolygons(ukcoastpoly, IDs, proj4string =crsDef,  checkHoles=FALSE)
ukcoastpolysp<-raster::crop(ukcoastpolysp, extent(xmin,xmax,ymin,ymax))

#ggplot()+gg(bathspdf)+gg(ukcoastpolysp)

# 2. Exact Coastline
coast<-sp::spTransform(coast, crsDef)
coast<-raster::crop(coast, extent(xmin,xmax,ymin,ymax))
#ggplot()+  gg(bathspdf)+  gg(coast)

# 3. Study Areas
studyA1<-sp::spTransform(studyA1, crsDef)
studyA1<-raster::crop(studyA1, extent(xmin,xmax,ymin,ymax))
studyA2<-sp::spTransform(studyA2, crsDef)
studyA2<-raster::crop(studyA2, extent(xmin,xmax,ymin,ymax))
studyA3<-sp::spTransform(studyA3, crsDef)
studyA3<-raster::crop(studyA3, extent(xmin,xmax,ymin,ymax))
#ggplot()+  gg(bathspdf)+  gg(coast)+  gg(studyA1)+  gg(studyA2)

# 4. Bathymetry
bath<-raster::projectRaster(bath, crs=crsDef)
bath<-raster::crop(bath, extent(xmin,xmax,ymin,ymax))
num<-na.omit(bath@data@values)
bath@data@values<-(bath@data@values-mean(num))/sqrt(var(num))
bathag<-raster::aggregate(bath, fact=aggr)
bathspdf<-as(bathag, "SpatialPixelsDataFrame")

f.bath <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  # Extract elevation values at spp coords, from our bathspdf SpatialGridDataFrame
  v <- over(spp, bathspdf)
  if (any(is.na(v$Depth))) {
    v$Depth <- inlabru:::bru_fill_missing(bathspdf, spp, v$Depth)
  }
  return(v$Depth)
}

#hist(f.bath(runif(100,xmin,xmax),runif(100,ymin,ymax))
bath.Plot<-ggplot()+
  gg(bathspdf)+ 
  gg(coast)+
  ggtitle("Bathymetry")+
  theme(axis.text.y =element_blank(), axis.text.x = element_blank())+
  gg(studyA1)+
  gg(studyA2)+
  gg(studyA3)




# 6. Coastal distance
distCoast<-raster::projectRaster(distCoast, crs=crsDef)
distCoast<-raster::crop(distCoast, extent(xmin,xmax,ymin,ymax))
num<-na.omit(distCoast@data@values)
distCoast@data@values<-(distCoast@data@values-mean(num))/sqrt(var(num))
distCoastag<-raster::aggregate(distCoast, fact=aggr)
distCoastspdf<-as(distCoastag, "SpatialPixelsDataFrame")

f.distCoast <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  v <- over(spp, distCoastspdf)
  if (any(is.na(v$dCoast))) {
    v$dCoast <- inlabru:::bru_fill_missing(distCoastspdf, spp, v$dCoast)
  }
  return(v$dCoast)
}
#hist(f.distCoast(runif(100,xmin,xmax),runif(100,ymin,ymax)))
distCoast.Plot<-ggplot()+gg(distCoastspdf)+  gg(coast)+ggtitle("Distance to coast")+theme(axis.text.y = element_blank(), axis.text.x = element_blank())+  gg(studyA1)+
  gg(studyA2)+
  gg(studyA3)

# 7. Colony distance
# i<-3 # gannets
# eval(parse(text=paste0("distCol",i,"<-raster::projectRaster(distCol",i,", crs=crsDef)")))
# eval(parse(text=paste0("distCol",i,"<-raster::crop(distCol",i,", extent(xmin,xmax,ymin,ymax))")))
distCol<-raster::projectRaster(distCol, crs=crsDef)
distCol<-raster::crop(distCol, extent(xmin,xmax,ymin,ymax))


distColS<-distCol

distColS@data@values<-log(distColS@data@values)
num<-na.omit(distColS@data@values)
distColS@data@values<-(distColS@data@values-mean(num))/sqrt(var(num))
distColS<-raster::aggregate(distColS, fact=aggr)
distColspdf<-as(distColS, "SpatialPixelsDataFrame")

f.distCol <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  v <- over(spp, distColspdf)
  if (any(is.na(v$dCol))) {
    v$dCol <- inlabru:::bru_fill_missing(distColspdf, spp, v$dCol)
  }
  return(v$dCol)
}

distCol.Plot<-ggplot()+gg(distColspdf)+  gg(coast)+ggtitle("Proximity to colonies (weighted)")+theme(axis.text.y = element_blank(), axis.text.x = element_blank())+  gg(studyA1)+
  gg(studyA2)+
  gg(studyA3)

# 8. Habitats


habitats<-raster::projectRaster(habitats, crs=crsDef)
habitats<-raster::crop(habitats, extent(xmin,xmax,ymin,ymax))
habitatsag<-raster::aggregate(habitats, fact=aggr)
habitats<-as(habitatsag, "SpatialPixelsDataFrame")
habitats$habitats<-factor(as.character(round(habitats$habitats)))
habitats$habitats[habitats$habitats==2]<-0
habitats$habitats<-factor(as.character(habitats$habitats))
levels(habitats$habitats)<-c("Undetermined","Rock","Coarse sed","Mixed sed","Sand","Mud")

f.habitat <- function(x, y) {
  # turn coordinates into SpatialPoints object:
  # with the appropriate coordinate reference system (CRS)
  spp <- SpatialPoints(data.frame(x = x, y = y), proj4string = crsDef)
  proj4string(spp) <- crsDef
  v <- over(spp, habitats)
  if (any(is.na(v$hab))) {
    v$hab <- inlabru:::bru_fill_missing(habitats, spp, v$hab)
  }
  return(v$hab)
}


habitat.Plot<-ggplot()+gg(habitats)+ gg(coast)+ggtitle("Habitats")+theme(axis.text.y = element_blank(), axis.text.x = element_blank())+  gg(studyA1)+
  gg(studyA2)+
  gg(studyA3)

multiplot(bath.Plot,distCoast.Plot,distCol.Plot, habitat.Plot, layout=matrix(c(1,2,3,4,5,6), 3,2))

```